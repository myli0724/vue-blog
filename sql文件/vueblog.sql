/*
 Navicat Premium Data Transfer

 Source Server         : 127.0.0.1
 Source Server Type    : MySQL
 Source Server Version : 50096
 Source Host           : localhost:3306
 Source Schema         : vueblog

 Target Server Type    : MySQL
 Target Server Version : 50096
 File Encoding         : 65001

 Date: 06/10/2021 17:51:10
*/

SET NAMES utf8;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for m_blog
-- ----------------------------
DROP TABLE IF EXISTS `m_blog`;
CREATE TABLE `m_blog`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `created` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' ON UPDATE CURRENT_TIMESTAMP,
  `status` tinyint(4) NULL DEFAULT NULL,
  PRIMARY KEY USING BTREE (`id`)
) ENGINE = InnoDB AUTO_INCREMENT = 35 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of m_blog
-- ----------------------------
INSERT INTO `m_blog` VALUES (29, 1, '【Java核心面试宝典】Day17、详解“Keep-Alive”和“非 Keep-Alive”区别及使用场景', '详解“Keep-Alive”和“非 Keep-Alive”区别及使用场景', '>Hello，你好呀，我是`灰小猿`！一个超会写bug的程序猿！\n>用坚持缔造技术、用指尖敲动未来！\n>和很多小伙伴们一样，我也是一名奔波在Java道路上的“`创造者`”。也想靠技术来改未来，改变世界！因为我们坚信每一次敲动键盘都能让`生活变得更智能、世界变得更有趣`！\n>**在此专栏《Java核心面试宝典》记录我们备战梦想的`【day 17】`！**\n>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/47f3489000474765b1324a509ad9c1fe.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4NTg4MA==,size_16,color_FFFFFF,t_70)\n\n今天我来和大家讲解一下HTTP协议中有关持久层连接和非持久层连接的几道常见面试题。\n## 一、“持久连接（Keep-Alive）和非持久连接（非Keep-Alive）的区别，他们对服务性能有影响吗？”\n\n在最早期的`HTTP/1.0`中，**浏览器每次发起HTTP请求都要与服务器建立一个TCP连接，服务器完成请求处理之后就会立即断开这个TCP连接，**因此服务器并不会跟踪每一个用户，同时也不会记录之前的请求信息。然而创建和关闭连接是需要消耗大量的资源和时间的，为了减少资源的消耗，缩短响应的时间，就需要重用连接。\n\n所以在之后的`HTTP/1.1`版本中就`默认使用持久连接`，而在之前的版本中默认使用的是非持久连接，\n\n**对于非Keep-Alive来说，** 对于每一个浏览器请求，我们必须为每一个请求的对象建立和维护一个全新的连接，同时对于每一个这样的连接，客户机和服务器都要分配TCP的缓冲区和变量，这就给服务器带来了严重的负担，因为一台web服务器可能服务数以百计的客户机请求，如果每一次请求对要不断的断开和重新建立连接，那么将会对服务器资源造成巨大的损失！\n\n**而在Keep-Alive方式下，** 服务器响应后保持该TCP连接打开，这样在同一台客户机和服务器之间进行的后续请求和响应报文就都可以通过这个TCP连接传输，甚至位于同一台服务器的多个web页面在向同一个客户机发送时，可以在单个持久的TCP连接上进行。\n\n我们可以通过下面这张图来表示Keep-Alive和非Keep-Alive连接。\n![请添加图片描述](https://img-blog.csdnimg.cn/da8c39b282ab4073bc8c3cd88009c753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4NTg4MA==,size_16,color_FFFFFF,t_70)==**但是对于Keep-Alive就没有缺点了吗？并不是的！**==\n\n## 二、追问：如何避免持久连接时系统资源被无效占用？\n**当我们长时间保持TCP连接时容易造成系统资源被无效占用，** 若对Keep-Alive模式配置不当，这样将可以会造成比非Keep-Alive方式更大的损失。因此我们需要正确的设置`Keep-Alive timeout`参数，当TCP连接传送玩最后一个HTTP响应后，该连接会保持`Keep-Alive_timeout`秒，之后断开并关闭这个连接！这样就会很好的避免系统资源被长时间无效的占用。\n\n\n## 三、追问：那么如果使用了旧版本的HTTP，如何维持持久连接呢？\n如果想要在旧版本的HTTP协议上维持持久连接，则需要指定`connection`的首部字段为`Keep-Alive`，来告诉对方这个请求完成后不要关闭，下一次还要使用这个连接进行通信。\n\n\n## 四、HTTP长连接和短连接的使用场景是什么？\n==**长连接：**== 长连接多用于`操作频繁`，`点对点的通讯`，而且`客户端连接数目较少`的情况。如即时通讯、网络游戏等。\n\n==**短连接：**== `用户数目较多`的web网站通常使用短连接，例如京东、淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若使用长连接势必会造成大量的资源被无效占用，所以一般使用短连接，请求处理完成即关闭！\n\n## 今日总结\n今天的文章主要和大家讲解了HTTP协议的持久连接和非持久连接的区别和使用，我们需要了解`持久连接和非持久连接的特点`，`两者之间如何转换`。`使用场景`等。\n\n如果小伙伴们有遇到其他相关的面试题，欢迎在评论区留言提出，我会把大家提出的总结到文章内, 欢迎小伙伴们一起评论区打卡学习！小伙伴们可也在左方加我好友一起探讨学习！\n\n我是 ==**灰小猿**== ，我们下期见！\n![请添加图片描述](https://img-blog.csdnimg.cn/cb2ff107d9e14962a64f5037c9ea6e54.jpg)\n\n\n', '2021-10-05 21:44:44', 0);
INSERT INTO `m_blog` VALUES (30, 1, '【Java核心面试宝典】Day20、如何进行DNS劫持并预防？', '如何进行DNS劫持并预防？', '>Hello，你好呀，我是`灰小猿`！一个超会写bug的程序猿！\n用坚持缔造技术、用指尖敲动未来！\n和很多小伙伴们一样，我也是一名奔波在Java道路上的“`创造者`”。也想靠技术来改未来，改变世界！因为我们坚信每一次敲动键盘都能`让生活变得更智能、世界变得更有趣`！\n**在此专栏[《Java核心面试宝典》](https://blog.csdn.net/weixin_44985880/category_10623253.html)记录我们备战梦想的`【day 20】`！**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9f0842063f7b483083160d37a65433c6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBA54Gw5bCP54y_,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n\nDNS大家都听说过吧？但是你知道他们的具体查询方式以及如何实现劫持吗？\n### 一、说一下DNS域名解析查询的两种方式？\n**（1）递归查询：** 如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户端的身份，向其他根域名服务器继续发出查询请求报文，即代替主机继续查询，而不是让主机查询。\n**（2）迭代查询：** 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应该找哪个域名服务器进行查询。然后让本地服务器进行后续查询。\nIP地址的查询过程如下：\n![请添加图片描述](https://img-blog.csdnimg.cn/e350e57d4bbd40298386e3fa39156906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBA54Gw5bCP54y_,size_48,color_FFFFFF,t_70,g_se,x_16)\n\n### 二、DNS使用什么传输协议？\n**`DNS既使用TCP协议又使用UDP协议。`**\n当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）的时候会使用**TCP协议**，因为数据同步传输的数据量比一个请求和应答的数据量更多，而TCP允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的TCP。\n\n当客户端向服务器查询域名（域名解析）的时候，一般返回的内容不会超过UDP报文的最大长度，即512字节。同时用UDP传输时不需要经过TCP的三次握手，大大的提高了响应速度。但是这也要求域名解析器和域名服务器能够自己解决超时和重传，从而保证可靠性。\n\n### 三、如何实现DNS劫持？\nDNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的 DNS 服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址。\n\n**具体实施步骤如下：**\n\n 1. 获取要劫持的域名信息：攻击者首先会访问域名查询站点查询要劫持的域名信息。 \n 2. 控制域名相应的 e-mail账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的 e-mail账号所对应的密码。更高级的攻击者甚至能够直接对 e-mail 进行信息窃取。\n 3. 修改注册信息：当攻击者破解了 e-mail后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS 服务器信息等。 \n 4.  使用e-mail收发确认函：在修改完注册信息后，攻击者在 e-mail真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成 DNS 劫持。\n\n### 四、追问：用户端有哪些预防手段？\n\n 1. 直接通过 IP 地址访问网站，避开 DNS 劫持。\n 2. 由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS指向正常的域名服务器以实现对目的网址的正常访问，例如将计算机首选 DNS 服务器的地址固定为 8.8.8.8。\n\n### 今日总结\n今天主要就是要了解`DNS域名解析的过程`，了解所使用的`传输协议`，了解`如何进行DNS劫持`,，以及`如何避免和预防`等。\n\n如果小伙伴们有遇到其他相关的面试题，欢迎在评论区留言提出，我会把大家提出的总结到文章内, 欢迎小伙伴们一起评论区打卡学习！小伙伴们可也在左方加我好友一起探讨学习！\n\n我是灰小猿，我们下期见！\n![请添加图片描述](https://img-blog.csdnimg.cn/4db79f5204fc48e7af127d1fcc0c93a6.jpg)\n\n', '2021-10-05 23:00:22', 0);
INSERT INTO `m_blog` VALUES (31, 1, '【Java核心面试宝典】Day19、HTTP协议面试题总结', 'HTTP协议面试题总结', '>Hello，你好呀，我是`灰小猿`！一个超会写bug的程序猿！\n用坚持缔造技术、用指尖敲动未来！\n和很多小伙伴们一样，我也是一名奔波在Java道路上的“`创造者`”。也想靠技术来改未来，改变世界！因为我们坚信每一次敲动键盘都能让`生活变得更智能、世界变得更有趣`！\n**在此专栏[《Java核心面试宝典》](https://blog.csdn.net/weixin_44985880/category_10623253.html)记录我们备战梦想的`【day 19】`！**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/07f5efee163a43b696df49306750bab0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBA54Gw5bCP54y_,size_20,color_FFFFFF,t_70,g_se,x_16)\n\nHTTP和HTTPS大家都知道吧？那你知道他们的连接方式、区别、加密方式等等吗？那今天这篇我就带大家来总结一下这其中会有哪些常见的面试题呢？\n\n### 一、HTTP和HTTPS的工作方式【建立连接的过程】\n**HTTP（超文本传输协议）** 是一种简单的`请求-响应`协议。被用于在web浏览器和网站服务器之间传递消息，HTTP使用`TCP`协议作为它的支撑运输层协议，其默认工作在TCP协议的80端口，HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问TCP，客户机从套接字接口发送HTTP请求报文和接收HTTP响应报文，类似的，服务器也是从套接字接口接收HTTP请求报文和发送HTTP响应报文。其通信内容以明文的形式发送，不通过任何形式的数据加密，当通信结束时，客户机和服务器关闭连接。\n\n**HTTPS**是以安全为目的的HTTP协议，在HTTP协议的基础上，通过`传输加密`和`身份认证`的方式保证了数据传输的安全性，其具体的工作流程是这样的：\n\n 1. 客户端发起一个HTTPS请求，并连接到服务器的443端口，发送的信息主要包括自身所支持的算法列表和密匙长度。\n 2. 服务器端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其他密匙组件一起发送给客户端。\n 3. 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。\n 4. 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。\n 5. SSL第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为`pre_master_secre`，并且该报文是经过证书中的公钥加密过的。\n 6. 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用`pre_master_secre` 加密的。\n 7. 客户端向服务端发送一个`finish` 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。\n 8. 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。\n\n当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，**之后就进行和 HTTP 相同的通信过程**，唯一不同的是在 HTTPS 通信过程中并不是采用`明文传输`，而是采用`对称加密`的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。\n\n\n### 二、说一说HTTPS和HTTP的区别？\n\n - HTTP采用`明文`的形式发送数据，数据不安全；\n -  HTTPS采用`对称加密算法`对传输的报文进行加密，保证了数据的安全性。\n - HTTP和HTTPS使用不同的连接方式，所使用端口也是不一样的，HTTP使用的端口是`80端口`，HTTPS使用的端口是`443`。\n - HTTPS需要向数字认证机构申请证书，一般是需要一定费用的、\n - HTTP比HTTPS响应速度快，原因是`HTTP采用3次握手建立连接`，客户端和服务器需要握手3次，而HTTPS除了需要3次握手之外，还需要经历`SSL的协商过程`。\n\n### 三、HTTPS的加密方式是怎样的？\nHTTPS采用`对称`和`非对称`相结合的方式，首先使用`SSL/TLS`协议进行加密传输，\n为了弥补非对称加密的不足，HTTPS采用证书来进一步加强非对称加密的安全性。通过非对称加密，客户端和服务器协商好进行通信传输的对称密匙，后续的所有信息通过该对称密匙进行加密解密，完成整个HTTPS的流程。\n\n> **所以简单来说就是：** HTTPS首先通过非对称加密算法将用于通信加密的对称加密密匙传输给对方，然后接下来的通信就使用对称加密了。\n\n### 四、客户端为什么信任第三方证书？\n假设中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后的签名，因此无法篡改签名。客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书被中间人篡改，证书不可信，从而终止向服务器传输信息。上述过程说明证书无法被篡改，\n\n我们考虑更严重的情况，例如中间人拿到了 CA 机构认证的证书，它想窃取网站 A 发送给客户端的信息，于是它成为中间人拦截到了 A 传给客户端的证书，然后将其替换为自己的证书。此时客户端浏览器收到的是被中间人掉包后的证书，但由于证书里包含了客户端请求的网站信息，因此客户端浏览器只需要把证书里的域名与自己请求的域名比对一下就知道证书有没有被掉包了。\n\n### 五、HTTP/1.1和HTTP/1.0的区别？\n**主要区别如下：**\n**缓存处理：** 在 HTTP/1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP/1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如 Entity-tag, If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头来控制缓存策略。\n\n**节约带宽：** 当客户端请求某个资源时，HTTP/1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP/1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。\n\n**错误通知的管理：** HTTP/1.1 在 1.0 的基础上新增了 24 个错误状态响应码，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。\n\n**Host 请求头：** 早期 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。为了支持虚拟主机，HTTP/1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。\n\n**长连接：** HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。\n\n### 六、HTTP/1.X 和 HTTP/2.0 的区别知道吗？\n相比于 HTTP/1.X 的`文本（字符串）`传送， HTTP/2.0 采用`二进制传送`。客户端和服务器传输数据时把数据分成帧，帧组成了数据流，流具有流 ID 标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题。\nHTTP/2.0 支持`多路复用`。因为流 ID 的存在， 通过同一个 HTTP 请求可以实现多个 HTTP 请求传输，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 HTTP 请求。\n\nHTTP/2.0 头部压缩。HTTP/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。\n\nHTTP/2.0 支持服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。\n\n### 七、HTTP/3了解吗？\nHTTP/3之所以会出现，**是因为HTTP/2存在一定的弊端，**\n我们知道，传统 Web 平台的数据传输都基于 TCP 协议，而 TCP 协议在创建连接之前不可避免的需要三次握手，如果需要提高数据交互的安全性，即增加传输层安全协议（TLS），还会增加更多的握手次数。 HTTP 从 1.0 到 2.0，其传输层都是基于 TCP 协议的。**即使是带来巨大性能提升的 HTTP/2，也无法完全解决 TCP 协议存在的固有问题**（`慢启动`，`拥塞窗口尺寸的设置`等）。此外，**HTTP/2 多路复用只是减少了连接数，其队头的拥塞问题并没有完全解决，倘若 TCP 丢包率过大，则 HTTP/2 的表现将不如 HTTP/1.1。**\n\nHTTP/3则是在`QUIC（快速UDP网络连接）`的基础上建立起来的，\n**QUIC的特点是：** 低延迟连接、能够避免HTTP/2的对头阻塞问题、传输的报文是经过加密和认证的、具有向前纠错机制，\n\nHTTP/3的`底层使用UDP进行数据传输`，上层仍然使用` HTTP/2`。在 UDP 与 HTTP/2 之间存在一个 QUIC 层，其中 TLS 加密过程在该层进行处理。HTTP/3 主要有以下几个特点：\n\n 1. 使用 UDP 作为传输层进行通信； \n 2. 在 UDP 之上的 QUIC 协议保证了 HTTP/3 的安全性。QUIC在建立连接的过程中就完成了 TLS 加密握手； \n 3. 建立连接快，正常只需要 1 RTT即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据； \n 4. 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立；\n 5. 使用 QPACK 进行头部压缩，因为 在 HTTP/2 中的HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题。 \n\n最后用这个图来表示HTTP的三次发展变化：\n![请添加图片描述](https://img-blog.csdnimg.cn/4435e8c89b884c28bfdd261e58214985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBA54Gw5bCP54y_,size_37,color_FFFFFF,t_70,g_se,x_16)\n\n### 今日总结\n今天的题目主要是关于HTTP协议的，理论性比较强，但是需要记忆的东西还是比较多的，包括`HTTP和HTTPS的工作方式`、`区别`、`HTTPS的加密方式`等。\n\n**如果小伙伴们有遇到其他相关的面试题，欢迎在评论区留言提出，我会把大家提出的总结到文章内,** 欢迎小伙伴们一起评论区打卡学习！小伙伴们可也在左方加我好友一起探讨学习！\n\n我是`灰小猿`，我们下期见！\n![请添加图片描述](https://img-blog.csdnimg.cn/c4b3f46bf875454f89febdfc8bfef051.jpg)\n\n\n', '2021-10-05 23:01:26', 0);
INSERT INTO `m_blog` VALUES (32, 1, '【Java核心面试宝典】Day16、“计算机网络协议层次及服务类型”面试题！✊✊✊', '“计算机网络协议层次及服务类型”面试题！✊✊✊', '>Hello，你好呀，我是`灰小猿`！一个超会写bug的程序猿！\n>用坚持缔造技术、用指尖敲动未来！\n>和很多小伙伴们一样，我也是一名奔波在Java道路上的“`创造者`”。也想靠技术来改未来，改变世界！因为我们坚信每一次敲动键盘都能让`生活变得更智能、世界变得更有趣`！\n>**在此专栏《Java核心面试宝典》记录我们备战梦想的`【day 16】`！**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/019909c4d29d42c79305ef9f6f95cfd8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4NTg4MA==,size_16,color_FFFFFF,t_70)\n\n前一部分和小伙伴分享了很多在Java基础和容器线程等方面的面试题，其中很多都是面试中常见的核心问题，小伙伴们可以一同去学习一下，今天我们来分享在计算机网络方面的面试题，计算机网络部分虽然枯燥且理论性强，但是这丝毫不影响面试官对我们的考察呀。\n今天我们的面试题就围绕这下面这个图展开，看一看单这一个图，能从中出多少面试题？\n![请添加图片描述](https://img-blog.csdnimg.cn/f4d906b98e9247b2b53111ae7293c4ec.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4NTg4MA==,size_16,color_FFFFFF,t_70)\n\n### 1、说一下OSI七层模型？\nOSI七层模型从低向上依次是：**物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。**\n\n### 2、说一下TCP/IP五层参考模型？\nTCP/IP五层模型包括：**物理层、数据链路层、网络层、传输层、应用层。**\n其中应用层对应OSI的上三层，下四层和OSI相同，五层协议的体系结构只是为了介绍网络原理而设计的。实际应用还是四层协议。\n\n### 3、说一下TCP/IP四层参考模型中每一层的作用？\nTCP/IP四层模型包括：**网络接口层、网际互连层、传输层。应用层。**\n这四层的作用分别是：\n**① 应用层**\nTCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。\n**② 传输层**\n该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。\n**③ 网际互联层**\n网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。\n**④ 网络接入层**\n网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。\n\n### 4、OSI模型和TCP/IP模型有哪些异同？\n**相同点：**\n\n 1. OSI模型和TCP/IP模型都采用了层次结构\n 2. 都能够提供面向连接和无连接的服务机制\n\n**不同点：**\n\n 1. OSI采用七层模型，TCP/IP是四层结构\n 2. TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。\n 3. OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP是先有协议集然后建立模型，不适用于非 TCP/IP 网络。\n 4. TCP/IP 一开始就提出面向连接和无连接服务，而 OSI一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。\n 5. OSI参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。\n\n### 5、OSI和TCP/IP协议之间的对应关系\nOSI和TCP/IP协议之间的对应关系以及他们哪一层中使用什么网络协议都要记清楚！\n![请添加图片描述](https://img-blog.csdnimg.cn/b1ef3516c9f94190b17382c76d843132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4NTg4MA==,size_16,color_FFFFFF,t_70)\n\n\n### 6、分别例举一下在TCP和UDP协议下有哪些常见的传输协议？\n有很多协议只支持TCP协议或UDP协议，所以我把这些协议以图表的形式给罗列了出来，\n![请添加图片描述](https://img-blog.csdnimg.cn/992cfa2dba8f4ef3b386a52e86652a6e.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4NTg4MA==,size_16,color_FFFFFF,t_70)\n\n\n### 7、为什么TCP/IP去除了表示层和会话层？\n原因是由于会话层、表示层、应用层都是在程序内部实现的。最终产出的是一个应用数据包，而应用程序之间几乎是无法实现代码的抽象共享的，这也就造成OSI设想中的应用程序维度的分层是无法实现的。例如，我们几乎不会认为数据的压缩、加密算法算是一种协议，而会话的概念则更为抽象，难以用协议来进行描述，所以在后来的 TCP/IP 协议框架的设计中，便将表示层和会话层与应用层整合在一起，让整个过程更为清晰明了。\n\n### 8、数据如何在各层之间传输【数据的封装过程】？\n在发送主机端，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。\n\n附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，在物理层数据帧被封装成比特流，之后通过\n传输介质传送到对端。\n\n### 今日总结\n今天只是了解了计算机网络的协议层次以及他们的服务类型，我们需要掌握的理论内容比较的多。\n\n**如果小伙伴们有遇到其他相关的面试题，欢迎在评论区留言提出，我会把大家提出的总结到文章内`,** 欢迎小伙伴们一起评论区打卡学习！小伙伴们可也在左方加我好友一起探讨学习！\n\n我是灰小猿，我们下期见！\n![请添加图片描述](https://img-blog.csdnimg.cn/7553519624ac4c048df320e4bfbbf1fa.jpg)\n\n', '2021-10-05 23:02:18', 0);
INSERT INTO `m_blog` VALUES (33, 1, '【Java核心面试宝典】Day15、“Java容器”高频面试题总结！✊✊✊', '“Java容器”高频面试题总结！✊✊✊', '>Hello，你好呀，我是`灰小猿`！一个超会写bug的程序猿！\n>用坚持缔造技术、用指尖敲动未来！\n>和很多小伙伴们一样，我也是一名奔波在Java道路上的“`创造者`”。也想靠技术来改未来，改变世界！因为我们坚信每一次敲动键盘都能让`生活变得更智能、世界变得更有趣`！\n>**在此专栏《Java核心面试宝典》记录我们备战梦想的`【day 15】`！**\n\n![请添加图片描述](https://img-blog.csdnimg.cn/f71f3bcd667746c9a7cc0e75ea07cf42.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4NTg4MA==,size_16,color_FFFFFF,t_70)\n集合、数组这些内容都是我们日常开发最常用到的东西，但是其中有很多能够被面试官拿来当做考察点的内容你知道嘛？今天就和小伙伴们剖析一下在容器的相关内容中，都会有哪些常见的面试题呢？\n\n### 1、Iterable和Iterator接口的作用分别是什么？\n`Iterable`接口的作用是使容器具备迭代元素的功能，如果一个容器类实现了`Iterable`接口，则该容器类的实例就具备了迭代元素的功能。\n`Iterator`接口的作用是迭代器，其作用是迭代容器中的元素。\n\n### 2、Iterable接口的核心方法是什么？该方法的返回值类型是什么？\nIterable接口的核心方法是`iterator`，该方法返回迭代器的实例，返回值类型是`Iterator`。\n\n### 3、如何实现在遍历过程中删除元素？\n为了实现在遍历中删除元素，最好的做法是使用迭代器进行元素遍历，当遇到需要删除的元素时，调用方法`remove`可以删除元素，并且不会出现错误。\n\n### 4、Collection接口继承了哪个接口？\nCollection接口继承了`Iterable`接口,\n关于容器中接口的继承和实现关系，可以看下面这张图：\n![请添加图片描述](https://img-blog.csdnimg.cn/e8b94d94bbdd419c8241c45dfbf173a4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4NTg4MA==,size_16,color_FFFFFF,t_70)\n\n### 5、Collection接口中的哪三个方法分别和集合的并集、差集、交集运算相似？\n方法`addAll`和集合的并集运算相似，**它的作用是一次将另一个容器中的元素全部添加到当前容器中。**\n\n方法`removeAll`和集合的差集运算相似，**它的作用是一次将另一个容器中的全部元素从当前容器中删除，**\n\n方法`retainAll`和集合的交集运算相似，**它的作用是保留既在当前容器中又在另一个容器中的元素。**\n\n\n### 6、Collection接口的两个子接口List和Set有什么不同？\n`List`是**线性表**，存储一组顺序排列的元素，==允许元素重复==；\n`Set`是**集合**，存储一组互不相同的元素，==不允许元素重复==。\n\n### 7、ListIterator类型的迭代器和Iterator类型的迭代器有什么区别？\n`Iterator`类型的迭代器只支持**单向遍历**，`ListIterator`类型的迭代器支持**双向遍历**。\n\n### 8、ArrayList和LinkedList的主要区别是什么？从底层实现、随机访问元素、插入和删除元素方面回答？\n`ArrayList`的底层实现是**数组**，`LinkedList`的底层实现是**双向链表**，\nArrayList可以快速访问指定下标处的元素。LinkedList需要遍历元素才能得到指定下标处的元素。ArrayList插入和删除元素时需要移动其他元素（除了在尾部插入和删除元素的情况），\nLinkedList可以快速插入和删除元素，但是在指定位置（除了头部和尾部）插入和删除元素时则需要首先遍历元素到指定位置。\n\n### 9、ArrayList和Vector的主要区别是什么？什么情况下使用 ArrayList 比使用 Vector 更好？\nArrayList和Vector的主要区别是，**Vector的所有方法都是同步的，因此可以保证线程安全。而ArrayList不能保证线程安全。**\n在不需要保证线程安全的情况下，使用 ArrayList 比使用 Vector 效率更高。\n\n### 10、Map中，键能否重复？如果重复，会有什么现象？\nMap中**不允许键重复**，因为每一个键对应一个值，如果有重复的键，则会出现一个键对应多个值的情况，这`违背了映射的定义`。\n\n### 11、HashMap和Hashtable的区别有哪些？\n==HashMap 不是线程安全的，Hashtable 是线程安全的；== HashMap 的效率高于 Hashtable；\nHashMap 允许键或值为 null，最多可以有一个键为 null，Hashtable 不允许键或值为 null；\n>**从 JDK 1.8 开始，HashMap 的实现包括红黑树，Hashtable 则没有这样的机制。** \n\n### 12、从JDK1.8之后，HashMap的实现有什么变化？\nJDK 1.8 之前的 HashMap 的底层通过数组和链表实现，如果出现冲突则通过拉链法解决冲突。\nJDK 1.8 在解决冲突时的实现有较大变化，**当链表长度大于阈值（默认为 8）时，将链表转化为红黑树。这便是“==树化==”，** **当链表长度小于6时，会重新形成链表，这个过程称为“==链化==”。**\n关于HashMap底层实现的深入探究，小伙伴们可以看这一篇《[【Java核心面试宝典】Day3、图解HashMap高频面试及底层实现架构！](https://blog.csdn.net/weixin_44985880/article/details/117629081)》。\n\n### 13、HashSet和TreeSet有什么区别？\nHashSet 的底层实现基于 HashMap，元素是**无序**的，通过方法 `hashCode` 和` equals` 保证元素没有重复；\nTreeSet 的底层实现基于 TreeMap，元素是有序的，通过 `Comparable` 接口或 `Comparator `接口保证元素没有重复。\n\n\n### 今日总结\n集合和容器相关的内容虽然经常用，但是我们可以看出能出的面试题其实一点都不少，这里面的很多都是重点，比如`HashMap的底层实现`、`列表接口的继承关系`、`实现原理`等。\n\n**这方面的题目还有很多，所以如果小伙伴们有遇到其他相关的面试题，欢迎在评论区留言提出，我会把大家提出的总结到文章内`,** 欢迎小伙伴们一起评论区打卡学习！小伙伴们可也在左方加我好友一起探讨学习！\n\n我是==灰小猿==，我们下期见！\n![请添加图片描述](https://img-blog.csdnimg.cn/96659df236ff47a19cd543b6eea04b39.jpg)\n\n', '2021-10-05 23:02:53', 0);
INSERT INTO `m_blog` VALUES (34, 1, 'SpringBoot与Vue交互解决跨域问题【亲测已解决】', '解决在使用vue和springboot在开发前后端分离的项目时，如何解决跨域问题。在这里分别分享两种方法，分别在`前端vue中解决`和在`后台springboot中解决`', 'Hello，你好呀，我是灰小猿，一个超会写bug的程序猿！\n\n最近在利用springboot+vue整合开发一个前后端分离的个人博客网站，所以这一篇总结一下在开发中遇到的一个问题，**关于解决在使用vue和springboot在开发前后端分离的项目时，如何解决跨域问题。在这里分别分享两种方法，分别在`前端vue中解决`和在`后台springboot中解决`。**\n\n# 浏览器同源策略\n**为什么会出现跨域问题？** 首先一个定义一定要了解，就是浏览器的同源策略，\n\n> **什么是浏览器的同源策略，** 简单来说就是浏览器发送请求的协议、域名和端口要和服务器接收请求的协议、域名以及端口一致。这样才能完成交互，但是很显然这样是不可能的，尤其在对于在同一台电脑上开发前后端分离的项目的时候，一定是会使用两个端口的。那么这样就形成了跨域问题。\n\n在这里分享一下我解决跨域问题用到的两个方法，\n\n# 一、VUE前端配置代理解决跨域\n## （1）Vue中让浏览器请求携带cookie\n先说一下我是怎么发现出现跨域问题的吧，最开始我在从前端浏览器向后台发送请求的时候是没有携带浏览器的cookie的，但是这样就导致了无法对浏览器的请求进行验证，**所以在后来我用了一个方法让浏览器在每次发送请求的时候在http请求头中携带上cookie，方法如下：**\n\n在vue的main.js方法中写入如下代码：\n\n```javascript\n//引入axios依赖\nimport axios from \'axios\'\n//让请求携带上浏览器的cookie\naxios.defaults.withCredentials=true\nVue.prototype.$axios = axios\n```\n\n以上表示引入axios请求，也就是ajax请求，同时开启写入凭证，**只有withCredentials等于true的时候，才会携带cookie。**\n\n## （2）vue中配置代理解决跨域\n在vue中解决跨域问题其实也比较简单，因为我们每次浏览器发送的请求中，URL的前半部分一定是相同的，比如http://localhost:8080/blogs与http://localhost:8080/login，我们就可以将他们相同的URL提取出来，封装到axios.defaults.baseURL中，这样我们在每次请求的时候，就可以将请求地址简写成“/blogs”这样，也相当于是将URL头部进行了一个简单的封装。\n\n> **`注意`：设置统一请求路径的axios.defaults.baseURL =\n> \"http://localhost:8080\"应该写在axios.js中**\n\n**但是在解决跨域问题的时候，我们应该将axios.defaults.baseURL = \"http://localhost:8080\"写成axios.defaults.baseURL = \"/api\"。**\n这样我们每次请求的路径前面都会是“/api”的形式。\n这也是第一步：\n## 第一步，设置统一访问路径\n\n> 在axios.js中设置axios.defaults.baseURL = \"http://localhost:8080\"写成**axios.defaults.baseURL = \"/api\"**\n\n\n### 第二步、配置跨域代理\n在babel.config.js的同级目录下新建一个js文件`vue.config.js`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6a25f4a0ab374f84af08ea9e6fed0b41.png)\n\n在其中写入如下代码：**这段代码是解决跨域问题而配置的一个代理。我这里后台服务器的请求连接是http://localhost:8081，所以如果你的不是的话需要修改一下。**\n\n```javascript\n/**\n * 解决跨域问题\n * @type {{devServer: {proxy: {\"/api\": {changeOrigin: boolean, pathRewrite: {\"^/api\": string}, target: string}}, host: string, open: boolean}}}\n */\nmodule.exports = {\n    devServer: {\n        host: \'localhost\',\n        open: true, // 自动打开浏览器\n        // 代理配置表，在这里可以配置特定的请求代理到对应的API接口\n        // 例如将\'localhost:8080/api/xxx\'代理到\'www.example.com/api/xxx\'\n        proxy: {\n            \'/api\': { // 匹配所有以 \'/api\'开头的请求路径\n                target: \'http://localhost:8081\', // 代理目标的基础路径\n                // secure: false,  // 如果是https接口，需要配置这个参数\n                changeOrigin: true, // 支持跨域\n                pathRewrite: { // 重写路径: 去掉路径中开头的\'/api\'\n                    \'^/api\': \'\'\n                }\n            }\n        }\n    }\n}\n\n```\n\n### 第三步、测试请求\n如我们现在要发送login登录请求，那么请求应该是这样写的：\n\n```javascript\nthis.$axios.post(\"/login\")\n```\n\n\n\n# 二、springboot后端配置解决跨域\n**在springboot框架的后端想要解决跨域问题，只需要添加一个类CorsConfig，并且让它实现WebMvcConfigurer接口，** 其中代码如下，一般在开发的时候直接将代码复制过去就可以了。\n\n```java\n\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n/**\n * 解决跨域问题\n */\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/**\")\n                .allowedOriginPatterns(\"*\")\n                .allowedMethods(\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")\n                .allowCredentials(true)\n                .maxAge(3600)\n                .allowedHeaders(\"*\");\n\n    }\n}\n\n```\n\n以上我解决跨域的两种方法，在网上也查找了很多解决跨域的方法，但是错综复杂，经过尝试和自己研究，以上两种方法是我亲测成功的，当时前后端都配置了。\n\n**所以小伙伴们有不同的见解或者更好的方法，`欢迎提出指正`！**\n\n**我是`灰小猿`，我们下期见！**\n\n![请添加图片描述](https://img-blog.csdnimg.cn/b28e482da8df4f12be4168f68e63d26d.jpg)\n\n', '2021-10-06 16:10:37', 0);

-- ----------------------------
-- Table structure for m_user
-- ----------------------------
DROP TABLE IF EXISTS `m_user`;
CREATE TABLE `m_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `status` int(5) NOT NULL,
  `created` datetime NULL DEFAULT NULL,
  `last_login` datetime NULL DEFAULT NULL,
  PRIMARY KEY USING BTREE (`id`),
  INDEX `UK_USERNAME` USING BTREE(`username`)
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of m_user
-- ----------------------------
INSERT INTO `m_user` VALUES (1, '灰小猿', 'https://img-blog.csdnimg.cn/20210427090206690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4NTg4MA==,size_16,color_FFFFFF,t_70', NULL, '123456', 0, '2020-04-20 10:44:01', '2020-04-20 10:44:01');

SET FOREIGN_KEY_CHECKS = 1;
